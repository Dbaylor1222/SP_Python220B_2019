"""Returns total price paid for individual rentals"""

import argparse
import json
import datetime
import math
import logging
import sys

def parse_cmd_arguments():
    """
    Allow command line interfacing.

    Required arguments: -i/--input (JSON file) and -o/--output (JSON file)
    Optional argument: -d (debug level), -s (switch off logging on select functions)
    """

    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '--input', help='input JSON file', required=True)
    parser.add_argument('-o', '--output', help='ouput JSON file', required=True)
    parser.add_argument('-d', '--debug',
                        help='set debug level: 0=No debug messages or log file, '
                             '1=Only error messages, 2=Error messages and warnings, '
                             '3=Error messages, warnings and debug messages',
                        default=0, type=int, choices=range(0, 4))
    parser.add_argument('-s', '--log_switch', help='switch off logging for select '
                                                   'functions: 0=off, 1=on',
                        default=1, type=int, choices=range(0, 2))
    return parser.parse_args()


# Collect log_switch info from cmd for logging_switch decorator
cmd_args = parse_cmd_arguments() # pylint: disable=invalid-name
logger = logging.getLogger() # pylint: disable=invalid-name
log_switch = cmd_args.log_switch # pylint: disable=invalid-name


def logging_switch(func):
    """Decorator to disable logging for wrapped functions."""
    def wrapper(*args, **kwargs):
        """Disable or enable logging for wrapped functions."""
        if log_switch == 0:
            logger.disabled = True
        return func(*args, **kwargs)
    return wrapper


def setup_logging(level):
    """Set up logging at defined level (level provided via command line)"""

    log_format = "%(asctime)s %(filename)s:%(lineno)-3d %(levelname)s %(message)s"
    formatter = logging.Formatter(log_format)
    log_file = "_".join(["charges_calc", datetime.datetime.now().strftime('%Y-%m-%d'),
                         f"level_{level}.log"])

    # File handler
    file_handler = logging.FileHandler(log_file)
    file_handler.setFormatter(formatter)

    # Console handler
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)

    # Supply handlers to "root" logger
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)

    if level == 0:
        logger.disabled = True

    if level == 1:
        logger.setLevel(logging.ERROR)
        console_handler.setLevel(logging.ERROR)
        file_handler.setLevel(logging.ERROR)

    elif level == 2:
        logger.setLevel(logging.WARNING)
        console_handler.setLevel(logging.WARNING)
        file_handler.setLevel(logging.WARNING)

    elif level == 3:
        logger.setLevel(logging.DEBUG)
        console_handler.setLevel(logging.DEBUG)


def load_rentals_file(filename):
    """
    Load the rentals file, a JSON containing the product_code, units_rented,
    price_per_day, rental_start date and rental_end date for each rental.
    """

    with open(filename) as file:
        try:
            data = json.load(file)
        except FileNotFoundError:
            logging.error("Could not find input file %s. Exited program.", filename)
            logging.debug("FileNotFoundError generated by load_rentals_file.")
            sys.exit()
    return data


@logging_switch
def calculate_additional_fields(data):
    """Expand data dict to include pricing and duration info for each order."""

    for key, value in data.items():

        # Validate rental_start and rental_end dates match required m/d/y formatting
        try:
            rental_start = datetime.datetime.strptime(value['rental_start'], '%m/%d/%y')
            rental_end = datetime.datetime.strptime(value['rental_end'], '%m/%d/%y')
        except (ValueError, SyntaxError) as err:
            logging.error("Start / end date formatting at %s "
                          "generates %s. Must be 'm/d/y' format.", key, err)
            logging.warning("%s date format is not 'm/d/y' format.", key)
            logging.debug("%s generated by calculate_additional_fields due to "
                          "incompatible start / end date input", err)

        # Calculate rental duration and pricing info
        try:
            value['total_days'] = (rental_end - rental_start).days
            value['total_price'] = value['total_days'] * value['price_per_day']
            value['sqrt_total_price'] = math.sqrt(value['total_price'])
            value['unit_cost'] = value['total_price'] / value['units_rented']

        except (ValueError, KeyError) as err:
            logging.error("Cannot take the square root of a negative number.")
            logging.warning("For %s, the total price is %s. This occurred "
                            "because the price_per_day is %s and the total_days "
                            "is %s.", key, value['total_price'],
                            value['price_per_day'], value['total_days'])
            logging.debug("%s generated by calculate_additional_fields "
                          "when trying to calculate rental duration and "
                          "pricing.", err)

    return data


@logging_switch
def save_to_json(filename, data):
    """
    Write the rentals summary file, a JSON containing the product_code,
    units_rented, price_per_day, rental_start date and rental_end date,
    as well as total_days, total_price, sqrt_total_price and unit_cost
    for each rental.
    """

    with open(filename, 'w') as file:
        json.dump(data, file)


if __name__ == "__main__":
    setup_logging(cmd_args.debug)
    incoming_data = load_rentals_file(cmd_args.input) # pylint: disable=invalid-name
    processed_data = calculate_additional_fields(incoming_data) # pylint: disable=invalid-name
    save_to_json(cmd_args.output, processed_data)
